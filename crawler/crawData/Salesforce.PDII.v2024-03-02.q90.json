[{"content":"A developer created a Lightning web component that uses a Lightning_record_edit_fom to collect Information about Leads. Users complain that they only see one error message at a time about their input when trying to save a Lead record.\nWhich best practice should the developer use to perform the validations on more than one held, thus allowing more than one error message to be displayed simultaneously?","options":["A. Apex REST","B. Client_side validation","C. Custom validation rules","D. Next Best Action"],"answer":"B","title":"Question 1","explanation":"When users need to see multiple error messages at a time related to their input on a form, client-side validation is the preferred method. This allows immediate feedback on the input fields without the need to submit the form to the server.\n Option B (Client-side validation) is correct because it enables validation of multiple fields before submitting the form, allowing users to see all error messages at once for the fields that fail validation.\n Options A (Apex REST), C (Custom validation rules), and D (Next Best Action) are not directly related to the validation of form inputs in the context of a Lightning web component.\n References:\n Lightning Web Components Developer Guide: Lightning Web Components and Salesforce Data"},{"content":"Universal Containers uses a custom Lightning page to provide a mechanism to perform a step-by-step wizard search for Accounts. One of the steps in the wizard is to allow the user to input text into a text field, ERF Number_c, that is then used in a query to find matching Accounts.\nWhich step should be taken to resolve the issue?","options":["A. Perform the SOQL query as part of a for loop.","B. Mark the ERP_Numker = field as an external 10.","C. Mark the ERP_Number__ c field as required.","D. Move the SO0L query to within an asynchronous process."],"answer":"D","title":"Question 2","explanation":"If a SOQL query is causing performance issues due to a non-selective query on a large data volume, moving the query to an asynchronous process such as a Batch Apex or Queueable Apex can help resolve the issue.\n This allows the query to run in the background without affecting the user's experience."},{"content":"A company has a Lightning page with many Lightning Components, some that cache reference data. It is reported that the page does not always show the most current reference data.\nWhat can a developer use to analyze and diagnose the problem in the Lightning page?","options":["A. Salesforce Lightning Inspector Transactions tab","B. Salesforce Lightning Inspector Actions tab","C. Salesforce Lightning Inspector Event Log tab","D. Salesforce Lightning Inspector Storage tab"],"answer":"D","title":"Question 3","explanation":"The Storage tab in the Salesforce Lightning Inspector can be used to view and manage data stored on the client side, such as in the cache. This is useful for diagnosing issues related to stale or outdated cache data that may prevent the most current reference data from displaying.References: Salesforce Lightning Inspector Chrome Extension"},{"content":"Consider the below trigger intended to assign the Account to the manager of the Account's region:\nWhich two changes should a developer make in this trigger to adhere to best practices?\nChoose 2 answers","options":["A. ","B. ","C. ","D. "],"answer":"B,C","title":"Question 4","explanation":"The best practices for writing triggers in Salesforce include bulkifying your code to handle multiple records efficiently and reducing the number of SOQL queries, especially within loops, to avoid hitting governor limits.\n Option B is correct because moving the SOQL query outside of the for loop is essential to bulkify the trigger. Performing a query within a loop can cause a SOQL governor limit to be reached if the trigger is processing many records. The best practice is to collect all necessary data before the loop starts and then process it within the loop.\n Option C is correct as well, because using a Map to cache the results of a SOQL query by Id is another way to bulkify the code. This allows you to query all the necessary data once and then access it efficiently in memory, avoiding repeated queries.\n Option A is incorrect because adding isExecuting before the update doesn't address any best practices related to bulkification or SOQL query optimization.\n Option D is incorrect because the last line should not be removed if the developer intends to perform DML on the accountList. However, this line should be outside of the loop and is unnecessary if the trigger context is 'before insert' or 'before update', since in those contexts, changes to records in Trigger.new are implicitly saved without the need for explicit DML.\n References:\n Apex Developer Guide on Triggers: Triggers and Order of Execution\n Salesforce Developer Blog on Trigger Best Practices: Trigger Best Practices"},{"content":"Universal Containers wants to use a Customer Community with Customer Community Plus licenses to allow their customers access to track how many containers they have rented and when they are due back. Universal Containers uses a Private sharing model for External users, Many of their customers are multi-national corporations with complex Account hierarchies. Each account on the hierarchy represents a department within the same business, One of the requirements is to allow certain community users within the same Account hierarchy to see several departments' containers, based on a custom junction object that relates the Contact to the various Account records that represent the departments.\nWhich solution solves these requirements?","options":["A. A Visualforce page that uses a custom controller that specifies without sharing [0 expose the records","B. An Apex trigger that creates Apex managed sharing records based on the junction object's relationships","C. A Lightning web component on the Community Home Page that uses Lightning Data Services.","D. A custom list view on the junction object with filters that will show the proper records based on owner"],"answer":"B","title":"Question 5","explanation":"For community users within the same Account hierarchy to see records based on a custom junction object, Apex managed sharing can be used. An Apex trigger can create sharing records based on the junction object relationships, allowing users to see records from different departments as required.References: Apex Developer Guide - Sharing a Record Using Apex"},{"content":"A developer needs to implement a historical Task reporting feature that allows users, assigned to a custom profile named \"Auditors\", to perform searches against the Tasks related to the Account object.\nThe developer must ensure the search is able to return Tasks that are between 12 and 24 months old. It should exclude any tasks which have been deleted, and include Tasks whether archived or not.\nGiven the following code, which select statement should be inserted at the placeholder as a valid way to retrieve the Tasks ranging from L2 to 24 months old?","options":["A. ","B. ","C. ","D. "],"answer":"C","title":"Question 6","explanation":"To retrieve Tasks that are between 12 and 24 months old, we need to use a SOQL query that filters based on the CreatedDate. The query must exclude deleted records and include both active and archived tasks. Since Tasks can be archived after a certain period (typically 12 months), we must ensure the query includes these as well.\n Option C is correct because it uses ALL ROWS in the SOQL query, which includes both active and archived (soft-deleted) records. The query also correctly uses a range for CreatedDate to ensure it selects Tasks created between 12 to 24 months ago.\n Option A is incorrect because it does not include the ALL ROWS keyword, which is necessary to include archived Tasks in the results.\n Option B is incorrect because it only retrieves Tasks created in the last 12 months, not between 12 to 24 months ago.\n Option D is incorrect because it does not filter Tasks based on their creation date correctly to include only those that are between 12 and 24 months old.\n References:\n Salesforce Developer Documentation on SOQL and SOSL Reference: SOQL and SOSL Reference Salesforce Developer Documentation on Working with Archived Records: Working with Archived Records"},{"content":"A Salesforce org has more than 50,000 contacts. A new business process requires a calculation that aggregates data from all of these contact records. This calculation needs to run once a day after business hours.\nwhich two steps should a developer take to accomplish this?\nChoose 2 answers","options":["A. ","B. ","C. ","D. "],"answer":"B,C","title":"Question 7","explanation":"When dealing with large datasets and the need to perform complex calculations or data aggregation, batch Apex and scheduling are typically used to efficiently process records in batches and to execute the process during off-peak hours.\n Option B is correct because using the @future annotation allows you to run methods in the background, but it is not suitable for operations that need to process more than 50,000 records, which is the governor limit for future methods.\n Option C is correct because implementing the Schedulable interface allows you to schedule the class to run at specified times, such as after business hours, which is a requirement for this scenario.\n Option A is incorrect because Queueable is typically used for chaining jobs and handling asynchronous processing of individual transactions, not for processing large datasets at scheduled times.\n Option D is incorrect because the Database.Batchable interface is what's needed for processing large datasets, not Database.Stateful. The Database.Stateful interface is used to maintain state across batch job transactions.\n References:\n Salesforce Developer Documentation on Using Batch Apex: Using Batch Apex Salesforce Developer Documentation on Scheduling Apex: Scheduling Apex"},{"content":"A developer is tasked with creating a Lightning web component that allows users to create a Case for a selected product, directly from a custom Lightning page. The input fields in the component are displayed in a non-linear fashion on top of an image of the product to help the user better understand the meaning of the fields.\nWhich two components should a developer use to implement the creation of the Case from the Lightning web component?\nChoose 2 answers","options":["A. Lightning-record-edit-forth","B. lightning-input-fimld","C. Lightning-input","D. lightning-record-form"],"answer":"C,D","title":"Question 8","explanation":"To implement a Lightning web component that allows users to create a Case, you would need components that allow for input fields and the creation of records.\n Option C (Lightning-input) is correct because it allows developers to create custom form input elements that can be positioned in a non-linear fashion as required.\n Option D (lightning-record-form) is correct because it provides a simple way to create forms for viewing and editing Salesforce records and would be suitable for creating a new Case record.\n Option A (Lightning-record-edit-form) is not a valid component; it seems to be a misprint of lightning-record-edit-form, which is indeed a component used for creating and editing records but was not listed as an option.\n Option B (lightning-input-field) is used within the lightning-record-edit-form or lightning-record-view-form components to create editable or displayable fields respectively, but is not as versatile as lightning-input for custom layout purposes.\n References:\n Lightning Web Components Documentation: Lightning-input"},{"content":"After a platform event is defined in a Salesforce org,events can be published via which mechanism?","options":["A. External Apps use an API Co publish event messages.","B. Internal Apps can use entitlement processes.","C. External Apps require the standard Streaming API.","D. Internal Apps can use outbound messages."],"answer":"A","title":"Question 9","explanation":"Platform events in Salesforce can be published using a variety of mechanisms, including from external applications through the Salesforce APIs.\n Option A is correct because external applications can use Salesforce APIs such as the REST API or the SOAP API to publish events to a platform event in Salesforce.\n Options B, C, and D describe mechanisms that are not used for publishing platform events. Entitlement processes are for setting up and tracking service contracts, the standard Streaming API is for subscribing to events not publishing them, and outbound messages are a workflow action used to send information to external services, not for publishing platform events.\n References:\n Salesforce Developer Documentation - Platform Events"},{"content":"What are three reasons that a developer should write Jest tests for Lightning web components?\nChoose 3 answers","options":["A. To test a component's non-public properties.","B. To test basic user interaction","C. To verify the DOM output of a component","D. To test how multiple components work together","E. To verify that events fire when expected"],"answer":"A,B,C","title":"Question 10","explanation":"Jest tests are essential for developing Lightning Web Components (LWC) because they allow developers to ensure the quality and correctness of their components in isolation from the rest of the application. Reason A is incorrect because testing non-public properties breaks encapsulation and is considered bad practice. B is correct because Jest tests can simulate user interactions with the component, such as clicking buttons or entering text, to ensure it behaves as expected. C is correct as well because Jest tests can confirm that the component renders the expected DOM output, which is crucial for ensuring that the HTML structure of the component is accurate. D is not the best choice since Jest is more suited for testing components in isolation rather than how multiple components interact; integration tests are more appropriate for that. Lastly, E is correct because Jest tests can verify that events are fired at the appropriate times, which is a critical part of the component's interaction with the rest of the application.\n References\n Jest Testing: Lightning Web Components Testing\n Jest Testing Best Practices: Lightning Web Components Jest Best Practices"},{"content":"Consider the following code snippet:\nAs part of the deployment cycle, a developer creates the following test class:\nWhen the test class runs, the assertion fails.\nWhich change should the developer implement in the Apex test method to ensure the test method executes successfully?","options":["A. ","B. ","C. ","D. "],"answer":"B","title":"Question 11","explanation":"To ensure that test methods execute successfully and are able to verify the behavior of the code, it is important to set up the proper context and to make sure that the test covers the expected outcomes accurately.\n Option B is correct because enclosing the method call within Test.startTest() and Test.stopTest() ensures that any asynchronous operations are completed before the assertions are made. This is crucial when the code being tested is expected to perform operations that may run after the initial transaction, such as future methods, queueable jobs, or batch operations.\n Options A, C, and D are incorrect because they do not address the issue of ensuring that all operations are completed before the assertion is made. Option A incorrectly suggests modifying the test setup code, while Options C and D suggest changes that are not related to the test execution flow.\n References:\n Salesforce Developer Documentation on Testing Best Practices: Apex Testing Best Practices"},{"content":"A developer created the following test method:\nThe developer org has five accounts where the name starts with \"Test\". The developer executes this test in the Developer Console.\nAfter the test code runs, which statement is true?","options":["A. The test will fail.","B. There will be no accounts where the name starts with \"Test\".","C. There will be five accounts where the name starts with \"Test\".","D. There will be six accounts where the name starts with \"Test\"."],"answer":"A","title":"Question 12","explanation":"Since the SeeAllData=true annotation is used, the test class does not have its own test data and is relying on the data in the org. The org already has accounts with the name starting with \"Test\", so the assertion that no accounts should exist after the deletion will fail because the test method only deletes the account that was created within its scope.\n References:\n Apex Developer Guide"},{"content":"A developer created and tested a Visualforce page in their developer sandbox, but now receives reports that user encounter view state errors when using it in production.\nWhat should the developer ensure to correct these errors?","options":["A. Ensure queries do net exceed governor limits,","B. Ensure properties are marked as private,","C. Ensure variables are marked as transient.","D. Ensure profiles have access to the Visualforce page."],"answer":"C","title":"Question 13","explanation":"The view state in Visualforce represents the state of the page - including the components, field values, and controller state. This error usually occurs when the page's view state becomes too large. To resolve this issue:\n C: Ensure variables are marked as transient: The transient keyword in Apex can be used to declare instance variables that should not be part of the view state and therefore not be saved. This is especially useful for large data that does not need to be maintained across postbacks.\n Marking properties as private (Option B) or ensuring queries do not exceed governor limits (Option A) might be best practices, but they do not directly impact the view state size. Ensuring profiles have access to the Visualforce page (Option D) is a matter of visibility and access, not related to view state errors.\n References:\n Salesforce Developer Documentation on View State: Visualforce View State"},{"content":"A developer notices the execution of all the test methods in a class takes a long time to run, due to the initial setup of all the test data that is needed to perform the tests. What should the developer do to speed up test execution?","options":["A. Define a method that creates test data and annotate with @testSetup.","B. Define a method that creates test data and annotate with @createData.","C. Ensure proper usage of test data factory in all test methods.","D. Reduce the amount of test methods in the class."],"answer":"A","title":"Question 14","explanation":"Using the @testSetup annotation to define a method that creates test data before the tests run can significantly speed up test execution by reducing the setup time for each test method in the class. This method runs once before any test method in the class and can be used by all test methods.References: Apex Developer Guide - Reducing Test Data Creation"},{"content":"A company's support process dictates that any time a case is closed with a status of \"Could net fix,\" an Engineering Review custom object record should be created and populated with information from the case, the contact, and any of the products associated with the case.\nWhat Is the correct way to automate this using an Apex trigger?","options":["A. An after update trigger on Case that creates the Engineering Review record and inserts it","B. An after upset trigger on Case that creates the Engineering Review record and inserts It .","C. A before update trigger on Case that creates the Engineering Review record and Inserts It","D. A before upset trigger on Case that creates the Engineering Review record and Inserts it"],"answer":"A","title":"Question 15","explanation":"In Salesforce, triggers can be defined to execute before or after a DML operation. An \"after\" trigger is used when you want to use the records that have been changed and rely on their committed values. In this scenario, you would use an after update trigger because you need to create a new record (Engineering Review) after the case has been updated with a status of \"Could not fix\". This cannot be done in a \"before\" trigger because the changes have not yet been committed to the database.\n Therefore, the correct answer is A, which specifies an after update trigger on the Case object to create and insert the Engineering Review record.\n References:\n Salesforce Developer Documentation on Triggers: Apex Developer Guide - Triggers"},{"content":"Which three Visualforce components can be used to initiate Ajax behavior to perform partial page updates?\nChoose 3 answers","options":["A. <apex:commondLink>","B. <apex:commandButton>","C. <Apex:form>","D. <apex:actionsStatus>","E. <apex:actionSupport>"],"answer":"A,B,E","title":"Question 16","explanation":"<apex:commandLink> and <apex:commandButton> components can cause the form data to be sent to the server and can be configured to refresh specific parts of the page.\n <apex:actionSupport> adds AJAX support to other components and can trigger partial page updates based on events such as onclick, onchange, etc.\n References:\n Visualforce Guide"},{"content":"A developer wrote the following method to find all the test accounts in the org:\nWhat should be used to fix this failing test?","options":["A. Test. fixsdSsarchReaulta [) method to set up expected data","B. @isTest (SeeAllData=true) to access org data for the test","C. @testsetup method to set up expected data","D. Teat.loadData to set up expected data"],"answer":"A","title":"Question 17","explanation":"https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_testing_SOSL.htm"},{"content":"Consider the following code snippet:\nA developer created the following test class to provide the proper code coverage for the snippet above:\nHowever, when the test runs, no data is returned and the assertion fails.\nWhich edit should the developer make to ensure the test class runs successfully?","options":["A. Implement the without sharing keyword in the searchFeaturs Apex class.","B. Implement the seeAllData=true attribute in the @1sTest annotation.","C. Enclose the method call within Test. startbest i) and @Test_stopTast |).","D. Implement the setFixedSearchResult= method in the test class."],"answer":"D","title":"Question 18","explanation":"To ensure that the test class for a search functionality in Salesforce runs successfully, the developer should use the Test.setFixedSearchResults() method. This allows the test to specify the records that are returned by the search, ensuring that the search behavior is predictable and that the assertion can be properly evaluated.References: Apex Developer Guide - Testing SOSL Queries"},{"content":"A developer built an Aura component for guests to self-register upon arrival at a front desk kiosk. Now the developer needs to create a component for the utility tray to alert users whenever a guest arrives at the front desk.\nWhat should be used?","options":["A. DML Operation","B. Changelog","C. Application Event","D. Component Event"],"answer":"C","title":"Question 19","explanation":"Application Events in Aura components are used for communication between components that are not in the same containment hierarchy. An application event to alert users about the arrival of a guest at the front desk is appropriate because it allows any component within the app to listen and respond to the event, regardless of where it is located in the component hierarchy.References: Aura Components Developer Guide - Application Event"},{"content":"A company has a custom object, Order__c, that has a custom picklist field, Status__c, with values of `\"New',\n`\"In Progress', or `\"Fulfilled' and a lookup field,\nContact__c, to Contact.\nWhich SOQL query will return a unique list of all the Contact records that have no `\"Fulfilled' Orders?","options":["A. SELECT Id FROM Contact WHERE Id NOT IN (SELECT Id FROM Order__c WHERE Status__c =\n         'Fulfilled')","B. SELECT Contact__c FROM Order__c WHERE Status__c <> 'Fulfilled'","C. SELECT Id FROM Contact WHERE Id NOT IN (SELECT Contact__c FROM Order__c WHERE Status__c = 'Fulfilled')","D. SELECT Contact__c FROM Order__c WHERE Id NOT IN (SELECT Id FROM Order__c Where Status__c = 'Fulfilled')"],"answer":"C","title":"Question 20","explanation":"The correct SOQL query to return a unique list of Contact records that have no 'Fulfilled' Orders is one that selects Ids from the Contact object where the Contact Id is not in the set of Contact Ids related to 'Fulfilled' Orders. This is done by a subquery that selects the Contact__c field from the Order__c records where the Status__c is 'Fulfilled'.References: SOQL and SOSL Reference Guide - Subqueries"},{"content":"A developer is writing a Visualforce page that queries accounts in the system and presents a data table with the results. The users want to be able to filter the results based on up to five fields. However, the users want to pick the five fields to use as filter fields when they run the page.\nWhich Apex code feature is required to facilitate this solution?","options":["A. Streaming API","B. Metadata APT","C. variable binding","D. dynamic SOQL"],"answer":"D","title":"Question 21","explanation":"The requirement described in the question calls for a flexible way to query records based on user-selected fields. Dynamic SOQL is the perfect tool for this job as it allows the construction of a SOQL string at runtime, which can include any number of fields and filter conditions that are determined at the time the user interacts with the page. This enables the creation of a highly customizable query interface. A, B, and C are not suitable for this requirement as they serve different purposes: A (Streaming API) is for receiving real-time streams of data changes, B (Metadata API) is for managing the metadata of your Salesforce org, and C (variable binding) is used in Visualforce to bind data between the page and the controller but does not provide dynamic query capabilities.\n References\n Dynamic SOQL: Dynamic SOQL in Apex Developer Guide"},{"content":"Universal Containers is leading a development team that follows the source-driven development approach in Salesforce. As part of their continuous integration and delivery (CL/CD) process, they need to automatically deploy changes to multiple environments, including sandbox and production.\n'Which mechanism or tool would best support their CI/CD pipeline in source-driven development?","options":["A. Salesforce CLI with Salesforce DX","B. Salesforce Extensions for Visual Studio Code","C. Change Sets","D. Ant Migration Tool"],"answer":"A","title":"Question 22","explanation":"Salesforce CLI with Salesforce DX supports source-driven development and is designed for continuous integration and delivery (CI/CD) processes. It enables developers to automate deployments across multiple environments, including sandbox and production.References: Salesforce DX Developer Guide"},{"content":"A developer is tasked with ensuring that email addresses entered into the system for Contacts and for a custom object called survey Response c do not belong to a list of blocked domains.\nThe list of blocked domains is stored in a custom object for ease of maintenance by users. The survey Response c object is populated via a custom Visualforce page.\nWhat is the optimal way to implement this?","options":["A. Implement the logic in validation rules on the Contact and the Burvey Response_c Objects.","B. Implement the logic in a helper class that is called by an Apex trigger on Contact and from the custom Visualforce page controller.","C. Implement the logic in an Apex trigger on Contact and also implement the logic within the custom Visualforce page controller.","D. Implement the logic in the custom Visualforce page controller and call \"that method from an Apex trigger on Contact."],"answer":"B","title":"Question 23","explanation":"The optimal way to enforce the exclusion of blocked domains for email addresses entered into Contacts and a custom object is to use a helper class. The class can be called by an Apex trigger on the Contact object and from the controller of the custom Visualforce page used for the Survey Response. This centralizes the logic for maintainability and reusability.References: Apex Developer Guide - Apex Triggers"},{"content":"A developer created a Lightning web component mat allows users to Input a text value that is used to search for Accounts by calling an Apex method. The Apex method returns a list of account to apply and is called imperatively from a JavaScript event handler.\nWhich two changes should the developer make so the Apex method functions correctly.\nChoose 2 answers","options":["A. Add @AuraEnabled to lines 11 and 12.","B. Add @AuraEnabled to line 09.","C. Add @AuraEnabled to line 03.","D. Add @AuraEnabled to line 01."],"answer":"A,C","title":"Question 24","explanation":""},{"content":"A company notices that their unit tests in a test class with many methods to create many records for prerequisite reference data are slow.\nWhat can a developer to do address the issue?","options":["A. Turn off triggers, flows, and validations when running tests.","B. Move the prerequisite reference data setup to a TestDataFactory and call that from each test method,","C. Move the prerequisite reference data setup to a @testSetup method in the test class.","D. Move the prerequisite reference data setup to the constructor for the test class."],"answer":"C","title":"Question 25","explanation":"@testSetup method improves test performance. It allows data sharing across test methods within a class, reducing redundant data creation.References: Using the testSetup Method"},{"content":"Exhibit.\nGiven the code above, which two changes need to be made in the Apex Controller for the code to work?\nChoose 2 answers","options":["A. Annotate the entire class as @AuraEnabled instead of just the single method.","B. Change the argument in the Apex Controller line 05 from subject to string.","C. Change the method signature to be global static, not public to String.","D. Remove line 06 from the Apex Controller and instead use firstName in the return on line 07."],"answer":"B,D","title":"Question 26","explanation":"Based on the code provided, here are the necessary changes:\n Change B is required because the argument in the Apex controller's serverEcho method must match the data type expected by the JavaScript calling the method. The Apex method expects an Object named firstName, which is then cast to a String inside the method. The JavaScript is passing an object with a property firstName, so no change is needed in the JavaScript.\n Change D is correct because line 06 is redundant and unnecessary. We can directly use firstName in the return statement as it is already a String type. The get() method is typically used when you have a Map and you need to retrieve a value by its key. Since firstName is already being passed as a String, there's no need to cast it or retrieve it using get().\n References:\n Apex Developer Guide"},{"content":"A company has a native iOS order placement app that needs to connect to Salesforce to retrieve consolidated information from many different objects in a JSON format.\nWhich is the optimal method to implement this in Salesforce?","options":["A. Apex REST web service","B. Apex SOAP web service","C. Apex SOAP callout","D. Apex REST callout"],"answer":"A","title":"Question 27","explanation":"Apex REST web services are the best method for creating custom endpoints that return data in a specific format, such as JSON, which is perfect for a native iOS application that needs to integrate with Salesforce for retrieving data.References: Apex Developer Guide - Exposing Apex Methods as REST Web Services"},{"content":"A developer is writing a Jest test for a Lightning web component that conditionally displays child components based on a user's checkbox selections.\nWhat should the developer do to properly test that the correct components display and hide for each scenario?","options":["A. Create a new describe block for each test.","B. Reset the DOM after each test with the after Each() method.","C. Add a teardown block to reset the DOM after each test.","D. Create a new jsdom instance for each test."],"answer":"B","title":"Question 28","explanation":"To ensure that the DOM is clean before each test runs, the developer should use the afterEach() method to reset it. This is part of the setup and teardown process in Jest tests, which helps to avoid state leakage between tests. References:\n Jest Globals afterEach"},{"content":"A developer has a Visualforce page that automatically assigns ewnership of an Account to a queue upon save.\nThe page appears to correctly assign ownership, but an assertion validating the correct ownership fails.\nWhat can cause this problem?","options":["A. The test class does not retrieve the updated value from the database,","B. The test class does not use the Bulk API for loading test data.","C. The test class does not use the seeallData=true= annotation.","D. The test class does not implement the Queueable interface."],"answer":"A","title":"Question 29","explanation":"If the test class does not retrieve the updated value from the database, it will not see any changes made by the page logic. This can cause assertions that check for those changes to fail. The test should query for the most recent value from the database after the operation that is supposed to update the value.References: Apex Developer Guide - Testing Best Practices"},{"content":"A developer needs to store variables to control the style and behavior of a Lightning Web Component.\nWhich feature can be used to ensure that the variables are testable in both Production and all Sandboxes?","options":["A. Custom setting","B. Custom object","C. Custom variable","D. Custom metadata"],"answer":"D","title":"Question 30","explanation":"Custom metadata types are the best feature for storing variables that control style and behavior of a Lightning Web Component. Unlike custom settings, custom metadata is deployable and testable in both Production and all Sandboxes.References: Salesforce Help - Custom Metadata Types Overview"},{"content":"Consider the controller code below that is called from an Aura component and returns data wrapped in a class.\nThe developer verified that the queries return a single record each and there is error handling in the Aura component, but the component is not getting anything back when calling the controller getSemeData.\n'What is wrong?","options":["A. Instances of Apex classes, such as MyDatsWrapper, cannot be returned to a Lightning component.","B. The member's Name and option should not have getter and setter.","C. The member's Name and option should not be declared public.","D. The member's Kame and option of the class MyDataWrapper should be annotated with @AuraEnabled also."],"answer":"D","title":"Question 31","explanation":"For the data to be passed back to the Aura component, all properties of the Apex class that are intended to be accessed from the component need to be annotated with @AuraEnabled. Without this annotation, the Aura framework cannot serialize the properties to send them to the front end.References: Aura Components Developer Guide - AuraEnabled Annotation"},{"content":"Universal Containers needs to integrate with their own, existing, internal custom web application. The web application accepts JSON payloads, resizes product images, and sends the resized images back to Salesforce.\nWhat should the developer use to implement this integration?","options":["A. An Apex trigger that calls an @future method that allows callouts","B. A platform event that makes a callout to the web application","C. A flow that calls an @future method that allows callouts","D. A flow with an outbound message that contains a session ID"],"answer":"A","title":"Question 32","explanation":"In a scenario where an integration requires making a callout to an external web application, Apex is often used to perform callouts. The callout must be asynchronous when being made from a trigger because a callout cannot be made from a synchronous operation like a trigger due to the possibility of long-running transactions.\n Option A (An Apex trigger that calls an @future method that allows callouts) is correct because it enables the trigger to perform an asynchronous callout to the external web application, which is necessary for sending JSON payloads and receiving the resized images.\n Options B, C, and D do not fit the requirement as well as option A because platform events and flows are typically not used for making direct callouts to external systems in the context described.\n References:\n Apex Developer Guide: Apex Web Services and Callouts"},{"content":"Which statement is considered a best practice for writing bulk safe Apex triggers?","options":["A. Add records to collections and perform DML operations against these collections.","B. Add LIMIT 50000 to every SOQL statement.","C. Perform all DML operations from within a future method.","D. Use the Database methods with allorNone set to £21s= instead of DML statements."],"answer":"A","title":"Question 33","explanation":"Bulk-safe triggers use collections to aggregate DML operations. This practice minimizes the number of DML statements, which is essential for bulk processing.References: Apex Developer Guide - Bulk Trigger Best Practices"},{"content":"Universal Containers is using a custom Salesforce application to manage customer support cases. The support team needs to collaborate with external partners to resolve certain cases. However, they want to control the visibility and access to the cases shared with the external partners. Which Salesforce feature can help achieve this requirement?","options":["A. Role hierarchy","B. Criteria-based sharing rules","C. Apex managed sharing","D. Sharing sets"],"answer":"C","title":"Question 34","explanation":"Apex managed sharing is the correct feature to control the visibility and access to cases shared with external partners. It allows developers to programmatically create sharing records that grant access to users based on specific criteria, providing granular control over record sharing.References: Apex Developer Guide - Sharing a Record Using Apex"},{"content":"What is a benefit of JavaScript remoting over Visualforce Remote Objects?","options":["A. Does not require any JavaScript code","B. Supports complex server-side application logic","C. Does not require any Apex code","D. Allows for specified re-render targets"],"answer":"B","title":"Question 35","explanation":"JavaScript remoting in Visualforce allows for the execution of complex server-side application logic without the need to refresh the entire page, providing a more dynamic user experience. It supports more complex operations than Visualforce Remote Objects, which are intended for basic CRUD operations.References:\n Visualforce Developer Guide - JavaScript Remoting"},{"content":"Which method should be used to convert a Date to a String in the current user's locale?","options":["A. String.format","B. Date.paras","C. Date. format","D. String.valueof"],"answer":"C","title":"Question 36","explanation":"The format method of the Date class is used to convert a Date to a String formatted in the current user's locale. This respects the locale settings of the user context under which the code is running, ensuring the date is represented in a way that is familiar to the user.\n References:\n Apex Developer Guide"},{"content":"Universal Containers uses Big Objects to store almost a billion customer transactions called Customer_Transaction__b.\nThese are the fields on Customer_Transaction__b:\nAccount__c -\nProgram__c -\nPoints_Earned__c -\nLocation__c -\nTransaction_Date__c -\nThe following fields have been identified as Index Fields for the Customer_Transaction__b object:\nAccount__c, Program__c, and Transaction_Date__c.\nWhich SOQL query is valid on the Customer_Transaction__b Big Object?","options":["A. SELECT Account__c, Program__c, Transaction_Date__c FROM Customer_Transaction__b WHERE Account__c = '001R000000302D3' AND Program__c ='Shoppers' AND Transaction_Date__c=2019-05-31T00:00Z","B. SELECT Account__c, Program__c, Transaction_Date__c FROM Customer_Transaction__b WHERE Account__c = '001R000000302D3' AND Program__c LIKE 'Shop%' AND Transaction_Date__c=2019-05-31T00:00Z","C. SELECT Account__c, Program__c, Transaction_Date__c FROM Customer_Transaction__b WHERE Account__c = '001R000000302D3' AND Program__c INCLUDES ('Shoppers', 'Womens') AND Transaction_Date__c=2019-05-31T00:00Z","D. SELECT Account__c, Program__c, Transaction_Date__c FROM Customer_Transaction__b WHERE Account__c = '001R000000302D3' AND Program__c EXCLUDES ('Shoppers', 'Womens') AND Transaction_Date__c=2019-05-31T00:00Z"],"answer":"A","title":"Question 37","explanation":"The valid SOQL query on a Big Object must match the indexed fields exactly. Since Account__c, Program__c, and Transaction_Date__c are the indexed fields, the SOQL query must specify those fields exactly in the WHERE clause, including exact match conditions (no LIKE or INCLUDES).References:\n Salesforce Developer Guide - Working with Big Objects"},{"content":"Which technique can run custom logic when a Lightning web component is loaded?","options":["A. Use an <aura:handler> init event to call a function.","B. Use the randersd loack { } method.","C. Call 52. engqueusiction and pass in the method to call.","D. Use the connectedCallback { } method."],"answer":"D","title":"Question 38","explanation":"The connectedCallback() lifecycle hook in Lightning Web Components (LWC) is used to perform logic after a component is inserted into the DOM, making it the ideal place to execute custom logic when the component is loaded.References: Lightning Web Components Developer Guide - Lifecycle Hooks"},{"content":"A developer created 2 class that implements the Queueable Interface, as follows:\nAs part of the deployment process, the developer is asked to create a corresponding test class.\nWhich two actions should the developer take to successfully execute the test class?\nChoose 2 answers","options":["A. Implement seeAllData=True to ensure the Queueable job is able to run in bulk mode.","B. Ensure the running user of the test class has, at I the View All permission on the Order object.","C. Enclose System.enqueueJob(new OrderQueueableJob ()] within Tess. and Test .stopTest (1.","D. Implement Test. isRunningTest() to prevent chaining jobs during test execution."],"answer":"C,D","title":"Question 39","explanation":"When writing a test class for a Queueable class in Salesforce, the goal is to ensure that the asynchronous code is executed within the test context and that it does not affect the state of the production org or depend on its data.\n Option C is correct because using Test.startTest() and Test.stopTest() ensures that the asynchronous code is executed immediately within the test's context. This is essential for testing Queueable classes because it allows the test to wait for the asynchronous process to complete before assertions are made.\n Without this, the asynchronous job would not necessarily run during the test execution.\n Option D is correct because Test.isRunningTest() can be used within the Queueable class to prevent the chaining of jobs during test execution. Chaining queueable jobs can lead to governor limits being hit and is generally not allowed in test methods. This conditional check allows the developer to bypass sections of the code not suitable for a testing context.\n Option A is incorrect because the seeAllData=True annotation is not required for testing Queueable classes, and it is not a best practice to depend on live data for tests. It's preferable to create test data within the test class itself.\n Option B is incorrect because having the 'View All' permission on the Order object is not related to the successful execution of the Queueable class in tests. Permissions are typically not enforced in test contexts unless using System.runAs() to test with a specific user context.\n References:\n Salesforce Documentation on Queueable Apex: Queueable Apex\n Salesforce Documentation on Testing Asynchronous Apex: Testing Asynchronous Apex"},{"content":"Given the following containment hierarchy:\nWhat is the correct way to communicate the new value of a property named ''passthrough'' to my-parent-component if the property is defined within my-child-component?","options":["A. ","B. ","C. ","D. "],"answer":"A","title":"Question 40","explanation":"To communicate a property change up a containment hierarchy in Lightning Web Components (LWC), the child component should dispatch a custom event with the detail of the change. The parent component listens for this event and handles it accordingly.\n Option A is the correct method because it creates a new custom event with the detail property containing the new value of passthrough. This event is then dispatched, and the parent component can listen for this event to handle the updated value.\n Options B, C, and D are incorrect because they either don't pass any data with the event or they don't use the detail object which is the standard way to pass data with custom events in LWC.\n References:\n Lightning Web Components Developer Guide - Communicating with Events"},{"content":"A developer is debugging an Apex-based order creation process that has a requirement to have three savepoints, SP1, SP2, and 5P3 {created in order), before the final execution of the process.\nDuring the final execution process, the developer has a routine to roll back to SP1 for a given condition. Once the condition is fixed, the code then calls 2 roll back to SP3 to continue with final execution. However, when the roll back to SP3 is called, a Funtime error occurs.\nWhy does the developer receive a runtime error?","options":["A. SP3 became invalid when SP1 was rolled back.","B. The developer has too many DML statements between the savepoints.","C. The developer used too many savepoints in one trigger session.","D. The developer should have called SF2 before calling SP3."],"answer":"A","title":"Question 41","explanation":"Savepoints in Apex are markers within a transaction and rolling back to an earlier savepoint (SP1) invalidates any savepoints created after it. Thus, SP3 is invalidated when the code rolls back to SP1, causing a runtime error when a rollback to SP3 is attempted.References: Apex Developer Guide - Savepoint and Transaction Control"},{"content":"A developer is inserting, updating, and deleting multiple lists of records in a single transaction and wants to ensure that any error prevents all execution.\nHow should the developer implement error exception handling in their code to handle this?","options":["A. Use Database methods to obtain lists of Database.SaveResults.","B. Use a try-catch statement and handle DML cleanup in the catch statement,","C. Use Database.setSavepoint {} and Database.rollBack with a try-catch statement.","D. Use a try-catch and use sObject.addError() on any failures."],"answer":"C","title":"Question 42","explanation":"Using Database.setSavepoint() and Database.rollback() within a try-catch statement is the recommended approach for handling transactions that involve multiple DML operations. This allows the developer to roll back all changes if an error occurs, ensuring that partial changes are not committed to the database.References:\n Apex Developer Guide - Savepoint and Transaction Control"},{"content":"When the sales team views an individual customer record, they need to see recent interactions for the customer. These interactions can be sales orders, phone calls, or Cases. The date range for recent interactions will be different for every customer record type.\nHow can this be accomplished?","options":["A. Use batch Apex to query for the most recent interactions when the customer view screen is loaded.","B. Use Lightning Flow to read the customer's record type, and then do a dynamic query for recent interactions and display on the View page.","C. Use a Lightning component to query and display interactions based on record type that is passed in using a design:attribute from the Lightning page.","D. Use a dynamic form on the customer record page to display recent interactions."],"answer":"C","title":"Question 43","explanation":"A Lightning component can dynamically query and display interactions based on the customer's record type.\n The component can receive the record type as a parameter and adjust the query accordingly, providing the required functionality without batch processing or additional configurations.References: Lightning Web Components Developer Guide - Communicating with Events"},{"content":"A developer is responsible for formulating the deployment process for a Salesforce project. The project follows a source-driven development approach, and the developer wants to ensure efficient deployment and version control of the metadata changes.\nWhich tool or mechanism should be utilized for managing the source-driven deployment process?","options":["A. Metadata API","B. Change Sets","C. Force.com IDE","D. Salesforce CLI with Salesforce DX"],"answer":"D","title":"Question 44","explanation":"Salesforce CLI with Salesforce DX is the best tool for managing a source-driven deployment process. It facilitates version control, scriptable deployment, and rollback, and is optimized for collaboration and continuous integration.References: Salesforce DX Developer Guide"},{"content":"A developer wrote a class named asccuntRisteryManager that relies on field history tracking. The class has a static method called getaccountHistory that Lakes in an Account as a parameter and returns a list of associated accountHistory object records.\nThe following test fails:\nWhat should be done to make this test pass?","options":["A. Create Accountdistory records manually in the test setup and write a query to get them.","B. Use @isTest (SeeAllData=true] to see historical data from the org and query for Accountdistory records.","C. Use Test. isRunningTest (] in getAccountHistory() to conditionally return fake AccountHistory records.","D. The tact method should he delated since this code cannat be tested"],"answer":"B","title":"Question 45","explanation":"To make the test pass, @isTest(SeeAllData=true) should be used to allow the test to access historical data from the org. This is required because field history tracking data is not copied to a test context, so you need to allow the test to access live data to assert against it.References: Apex Developer Guide - IsTest Annotation"},{"content":"A developer created a Lightning web component for the Account record page that displays the five most recently contacted Contacts for an Account. The Apex method, Contacts, returns a list of Contacts and will be wired to a property in the component.\nWhich two lines must change in the above code to make the Apex method able to be wired?\nChoose 2 answers","options":["A. Add @AuraEnabled {cacheable=trues) to line 08.","B. Remove private from line 09.","C. Add public to line 04.","D. Add @AuraEnabled {cacheable=true) to line 03."],"answer":"A,B","title":"Question 46","explanation":"To make an Apex method callable from a Lightning Web Component, you need to annotate the method with\n @AuraEnabled and mark it as cacheable if it's only retrieving data without modifying it. Additionally, the method must be public to be accessible from the component.\n Line 04: Needs @AuraEnabled(cacheable=true) to allow the method to be called from the Lightning Web Component and indicate that the method doesn't modify any data, making it suitable for caching.\n Line 09: The method getFiveMostRecent should not be private because private methods cannot be called from a Lightning Web Component. Changing it to public (or default, which is equivalent to public within the same namespace) is required.\n References:\n Lightning Web Components and Salesforce Data: Developer Documentation\n @AuraEnabled Annotation: Apex Developer Guide"},{"content":"A developer writes a Lightning web component that displays a dropdown list of all custom objects in the org from which a user will select. An Apex method prepares and returns data to the component.\nWhat should the developer do to determine which objects to include in the response?","options":["A. Check the isCustom() value on the sObject describe result,","B. Import the list of all custom objects from @salesforce/schema.","C. Check the getobiectType [) value for 'Custom' or \"Standard' on the sObject describe result.","D. Use the getcustomobjects() method from the Schema class."],"answer":"A","title":"Question 47","explanation":"To determine which objects to include in the response, the developer should check the isCustom() value on the sObject describe result. This method returns a Boolean indicating whether the sObject is a custom object.References: Apex Developer Guide - Describing sObjects"},{"content":"When developing a Lightning web component, which setting displays lightninglayout-items im one column on small devices, such as mobile phones, and in two columns on tablet-size and desktop-size screens?","options":["A. Set size=\"12\" tablet-device-size=\"6\"","B. Set size=\"12\" medium-device-size=\"6\"","C. Set size=\"6\" mobile-device-size=\"12\"","D. Set size=\"6\" small-device-size=\"12\""],"answer":"B","title":"Question 48","explanation":"To display lightning-layout-items in one column on small devices and in two columns on larger devices, you should set the size attribute to \"12\" for small devices and the medium-device-size attribute to \"6\". This ensures that on small devices each item takes the full width, and on medium or larger devices, items take up half the width.References: Lightning Web Components Developer Guide - Layout Components"},{"content":"Refer to the following code snippets:\nA developer is experiencing issues with a Lightning web component. The component must surface information about Opportunities owned by the currently logged-in user.\nWhen the component is rendered, the following message is displayed: \"Error retrieving data\".\nWhich modification should be implemented to the Apex class to overcome the issue?","options":["A. Use the Cacheable=true attribute in the Apex method,","B. Ensure the OWD for the Opportunity object is Public.","C. Edit the code to use the w. cut sharing keyword in the Apex class.","D. Use the Continuation=true attribute in the Apex method."],"answer":"A","title":"Question 49","explanation":"The @AuraEnabled(cacheable=true) attribute allows caching of method results on the client side, reducing server trips for already fetched data, which is useful for read-only data.References: Aura Components Developer Guide - AuraEnabled Annotation"},{"content":"Refer to the exhibit\nUsers of this Visualforce page complain that the page does a full refresh every time the Search button Is pressed.\nWhat should the developer do to ensure that a partial refresh Is made so that only the section identified with opportunity List is re-drawn on the screen?","options":["A. Enclose the DATA table within the <apex:actionRegion> tag.","B. Implement the render attribute on the <apex:ccxmandButton> tag.","C. Ensure the action method search returns null.","D. Implement the <apex:actionfunction> tag with immediate = true."],"answer":"B","title":"Question 50","explanation":"To ensure that only a part of the Visualforce page is refreshed, developers can use the reRender attribute of the <apex:commandButton> tag. This attribute specifies the IDs of the components that should be re-rendered as a result of the action method being completed. In this case, setting the reRender attribute to the ID of the <apex:pageBlockSection> that contains the opportunity list will cause only that section to be updated on the page, resulting in a partial page refresh.\n The correct answer is B because it uses the reRender attribute correctly to update only the specific part of the page (opportunityList) without a full page refresh.\n References:\n Salesforce Developer Documentation on Visualforce AJAX Components: Visualforce Developer Guide\n - CommandButton"},{"content":"A developer wrote an Apex class to make several callouts to an external system.\nIf the URLs used in these callouts will change often, which feature should the developer use to minimize changes needed to the Apex class?","options":["A. Session Id","B. Connected Apps","C. Named Credentials","D. Remote Site Settings"],"answer":"C","title":"Question 51","explanation":"The correct feature to use is C, Named Credentials. Named Credentials are a secure way of storing the endpoint and authentication details for callouts to external services. When URLs change frequently, using Named Credentials allows you to manage the endpoint URL in one place without changing the Apex code.\n References:\n Named Credentials"},{"content":"A developer has a test class that creates test data before making a mock callout but now receives a 'You have uncommitted work pending. Please commit or rollback before calling out' error.\nWhich step should be taken to resolve the error?","options":["A. Ensure both the Insertion and mock callout occur after the I==L. stoptest_().","B. Ensure the records are Inserted before the Tezt.startTest() statement and the mock callout occurs within a method annotated with @testSetup.","C. Ensure both the insertion and mock callout occur after the Test.startTest().","D. Ensure the records are inserted before the Test.startTess() statement and the mock callout occurs after the Test. Startest()."],"answer":"D","title":"Question 52","explanation":"When working with Apex tests that involve callouts, it's important to avoid the 'uncommitted work pending' error. This error typically occurs because DML operations (like inserts) are pending when a callout is attempted. Salesforce requires that all callouts are made before any DML operations in a transaction. To avoid this, the pattern is to insert the records before calling Test.startTest(), and then make the callout after this call.\n Test.startTest() marks the point where your actual test begins, and it resets the governor limits. By making the callout after this point, it ensures that the DML operations are committed and you are within a new execution context regarding governor limits.\n References:\n Testing HTTP Callouts by Implementing the HttpCalloutMock Interface\n Understanding Execution Contexts"},{"content":"A company uses Dpportunities to track sales to their customers and their org has millions of Opportunities.\nThey want to begin to track revenue over time through a related Revenue object.\nAs part of their initial implementation, they want to perform a one-time seeding of their data by automatically creating and populating Revenue records for Opportunities, based on complex logic.\nThey estimate that roughly 100,000 Opportunities will have Revenue records created and populated.\nWhat is the optimal way to automate this?","options":["A. Use system, acheduladeb() to schedule a patakape.Scheduleable class.","B. Use system, enqueuJob (| to invoke a gueusable class.","C. Use Database. executeBatch () to invoke a Queueable class.","D. Use Database. =executeBatch() to invoke a Database. Batchable class."],"answer":"D","title":"Question 53","explanation":"For a one-time bulk operation on a large data set, using a Database.Batchable class is the best approach. This allows complex logic to be processed in manageable chunks and efficiently manages system resources.References: Apex Developer Guide - Using Batch Apex"},{"content":"A developer is developing a reusable Aura component that will reside on an sObject Lightning page with the following HTML snippet:\nHow can the component\"5 controller get the context of the Lightning page that the sObject is on without requiring additional test coverage?","options":["A. Add force:hasSobjectName to the implements attribute.","B. Use the gerSubjectType method in an Apex class.","C. Set the sObject type as a component attribute.","D. Create a design attribute and configure via App Builder."],"answer":"A","title":"Question 54","explanation":"By implementing force:hasSobjectName, the Aura component can retrieve the sObject context of the record page it is placed on without needing additional information. This interface provides the component with the API name of the sObject being displayed.\n References:\n Aura Components Developer Guide"},{"content":"When the code is executed, the callout is unsuccessful and the following error appears within the Developer Console:\nSystem.CalloutException: Unauthorized endpoint\nWhich recommended approach should the developer implement\nto resolve the callout exception?","options":["A. Annotate the getkRFCatalogContents method with @Future (Callout-true),","B. Change the access modifier for ERPCatalog from public to global.","C. Use the SetHeader() method to specify Basic Authentication,","D. Create a remote site setting configuration that includes the endpoint."],"answer":"D","title":"Question 55","explanation":"The System.CalloutException with the message \"Unauthorized endpoint\" typically indicates that the endpoint to which the callout is being made has not been authorized in the Salesforce org's security settings. To resolve this, the developer must navigate to the Remote Site Settings in the Salesforce Setup and add the endpoint URL as a new remote site. This step is necessary to authorize the Salesforce org to send outbound callouts to that specific endpoint. Annotating with @Future(Callout=true) is necessary for making callouts from methods that perform DML operations, but it does not resolve endpoint authorization issues. Similarly, changing the access modifier or using SetHeader() for authentication would not address the unauthorized endpoint error.\n References:\n Remote Site Settings\n Apex Developer Guide: Making Callouts Using Apex"},{"content":"Which Salesforce feature allows a developer to see when a user last logged in to Salesforce if real-time notification is not required?","options":["A. Calendar Events","B. Asynchronous Data Capture Events","C. Event Monitoring Log","D. Developer Log"],"answer":"C","title":"Question 56","explanation":"Event Monitoring Log provides the ability to track different types of events in Salesforce, including user logins. These logs can be used to determine the last login time of a user without the need for real-time notification.References: Salesforce Help - Event Monitoring"},{"content":"A company has a custom component that allows users to search for records of a certain object type by invoking an Apex Controller that returns a list of results based on the user's input. When the search is completed, a searchComplete event is fired, with the results put in a results attribute of the event. The component is designed to be used within other components and may appear on a single page more than once.\nWhat is the optimal code that should be added to fire the event when the search has completed?","options":["A. ","B. ","C. ","D. "],"answer":"B","title":"Question 57","explanation":"The correct code to fire the event when the search has completed in a Lightning component is option B.\n $A.get(\"e.c.searchComplete\") is the syntax used to get the event, setParams is used to set the parameters, and fire is used to dispatch the event.References: Lightning Components Developer Guide - Firing Events"},{"content":"A company has an Apex process that makes multiple extensive database operations and web service callouts.\nThe database processes and web services can take a long time to run and must be run sequentially.\nHow should the developer write this Apex code without running into governor limits and system limitations?","options":["A. Use Queueable Apex to chain the jobs to run sequentially.","B. Use Apex Scheduler to schedule each process.","C. Use multiple 3zutuze methods for each process and callout.","D. Use Limits class to stop entire process once governor limits are reached."],"answer":"A","title":"Question 58","explanation":"Queueable Apex is suitable for complex processes that require chaining jobs to run sequentially. It can handle long-running processes without hitting governor limits, as each chained job runs in a new transaction with its own set of governor limits.References: Apex Developer Guide - Queueable Apex"},{"content":"Consider the following code snippet:\nThe Apex method is executed in an environment with a large data volume count for Accounts, and the query is performing poorly.\nWhich technique should the developer implement to ensure the query performs optimally, while preserving the entire result set?","options":["A. Create a formula field to combine the createdDate and RecordType value, then filter based on the formula.","B. Break down the query into two individual queries and join the two result sets.","C. Annotate the method with the @Future annotation","D. Use the Database queryLocator method to retrieve the accounts."],"answer":"D","title":"Question 59","explanation":"When dealing with large data volumes in Salesforce and ensuring optimal performance for queries, it's important to choose an approach that both handles the data volume efficiently and retrieves the complete result set.\n Option D is correct because using the Database.QueryLocator method is a best practice for handling large data volumes. It is typically used with batch Apex, which can process records in batches, thus reducing the likelihood of hitting governor limits. It's designed to handle very large data sets that would otherwise exceed normal SOQL query limits.\n Option A is incorrect because creating a formula field doesn't improve the performance of the query. It simply creates a new field that combines existing data, but it does not inherently optimize the query execution.\n Option B is incorrect because breaking down the query into two parts and joining them in Apex could potentially be less efficient and would require additional code to manage the combined result sets. This approach does not leverage the built-in Salesforce features designed to handle large data volumes.\n Option C is incorrect because the @Future annotation makes the method execute asynchronously, but it does not help with query performance or large data volume management.\n References:\n Salesforce Documentation on Working with Very Large SOQL Queries: Working with Very Large SOQL Queries Salesforce Documentation on Using Batch Apex: Using Batch Apex"},{"content":"Universal Containers develops a Salesforce application that requires frequent interaction with an external REST API.\nTo avoid duplicating code and improve maintainability, how should they implement the APL integration for code reuse?","options":["A. Use a separate Apex class for each API endpoint to encapsulate the integration logic,","B. Include the API integration code directly in each Apex class that requires it.","C. Create a reusable Apex class for the AFL integration and invoke it from the relevant Apex classes.","D. Store the APT integration code as a static resource and reference it in each Apex class."],"answer":"C","title":"Question 60","explanation":"Creating a reusable Apex class for API integration allows for code encapsulation and maintainability. This class can then be invoked from any other Apex class that requires interaction with the API, preventing code duplication.References: Apex Developer Guide - Apex Classes"},{"content":"Which interface needs to be implemented by an Aura component so that it may be displayed in modal dialog by clicking a button on a Lightning record page?","options":["A. farce:lightningEditRAation","B. lightning:editiction","C. force:lightningQuickhction","D. lightning:quickAction"],"answer":"C","title":"Question 61","explanation":"To display an Aura component in a modal dialog, the component must implement the force:lightningQuickAction or force:lightningQuickActionWithoutHeader interface. This allows it to be used as a quick action on record pages.References: Aura Components Developer Guide - Using Components in Quick Actions"},{"content":"A developer wrote a trigger on Opportunity that will update a custom Last Sold Date field on the Opportunity's Account whenever an Opportunity is closed. In the test class for the trigger, the assertion to validate the Last Sold Date field fails.\nWhat might be causing the failed assertion?","options":["A. The test class has not defined an Account owner when inserting the test data.","B. The test class has not implemented seealldata=true in the test method.","C. The test class has not re-queried the Account record after updating the Opportunity.","D. The test class is not using System. runs () to run tests as a Salesforce administrator."],"answer":"C","title":"Question 62","explanation":"The test class may not be re-querying the Account record after updating the Opportunity, which is necessary to verify the updated field values. If the test does not query the database to get the most recent data after the trigger runs, it will not see the changes made by the trigger.References: Apex Developer Guide - Testing Best Practices"},{"content":"Universal Containers analyzes a Lightning web component and its Apex controller class that retrieves a list of contacts associated with an account. The code snippets are as follows:\nBased on the code snippets, what change should be made to display the contacts' mailing addresses in the Lightning web component?","options":["A. Add a new method in the Apex controller class to retneve the mailing addresses separately and modify the Lightning web component to invoke this method.","B. Extend the lightning-datatable component in the Lightning web component to include a column for the MailingAddress field.","C. Modify the SOQL guery in the getAccountContacts method to include the MailingAddress field.","D. Modify the SOQL query in the getAccountContacts method to include the MailingAddress field and update the columns attribute in javascript file to add Mailing address fields."],"answer":"D","title":"Question 63","explanation":"To display the contacts' mailing addresses in the Lightning web component, both the SOQL query in the getAccountContacts method and the columns attribute in the JavaScript file of the component need to be updated. The query must include the MailingAddress field, and the JavaScript file must be modified to add this field to the columns shown in the lightning-datatable.References: Lightning Web Components Developer Guide - lightning-datatable"},{"content":"An Apex trigger and Apex class increment a counter, Edit __C, any time the Case is changed.","options":["A. ","B. ","C. ","D. "],"answer":"A","title":"Question 64","explanation":""},{"content":"A company has a web page that needs to get Account record information, such as name, website, and employee number. The Salesforce record 1D is known to the web page and it uses JavaScript to retrieve the account information.\nWhich method of integration is optimal?","options":["A. Apex SOAP web service","B. SOAP API","C. Apex REST web service","D. REST API"],"answer":"D","title":"Question 65","explanation":"For retrieving specific records using a known ID, the REST API is optimal due to its stateless, cacheable communications and lightweight structure. It's ideal for web applications that use JavaScript to make requests directly from the user's browser. Using the REST API, the web page can make a simple HTTP GET request to the Salesforce REST service endpoint and retrieve the account information in a format that's easily handled by JavaScript (typically JSON).\n References:\n REST API Developer Guide"},{"content":"A user receives the generic \"An internal server error has occurred\" while interacting with a custom Lightning component.\nWhat should the developer do to ensure a more meaningful message?","options":["A. Add an onerror event handler to the tag.","B. Add an error-view component to the markup.","C. Use platform events to process the error","D. Use an AuraHandledexception in a try-catch block."],"answer":"D","title":"Question 66","explanation":"Use AuraHandledException in try-catch for custom errors. It enables sending meaningful, user-friendly error messages to the Lightning component.References: Handling Errors in Lightning Components"},{"content":"A developer is building a Lightning web component that retrieves data from Salesforce and assigns it to the record property.\nWhat must be done in the component to get the data from Salesforce?","options":["A. ","B. ","C. "],"answer":"A","title":"Question 67","explanation":"Option A is the correct answer. The @wire decorator is used in conjunction with getRecord from lightning/uiRecordApi to retrieve a record from Salesforce. The syntax @wire(getRecord, { recordId: '\n $recordId', fields: '$fields' }) sets up a reactive property, which means it will automatically rerun whenever the recordId or fields property changes.\n References:\n Get Record Data"},{"content":"A page throws an 'Attempt to dereference a null object' error for a Contact.\nWhat change in the controller will fix the error?","options":["A. Declare a static final Contact at the top of the controller.","B. Use a condition in the getter to return a new Contact if it is null.\n         G Change the setter's signature to return a Contact.","C. Change the getter's signature to be static Contact."],"answer":"B","title":"Question 68","explanation":"The error 'Attempt to dereference a null object' often occurs when trying to access a member of a null object.\n By checking if the object is null in the getter method and returning a new instance if it is, the error can be prevented.\n References:\n Apex Developer Guide"},{"content":"An Apex class does not achieve expected code coverage. The testsetup method explicitly calls a method In the Apex class..\nHow can the developer generate the code coverage?","options":["A. Use system.assert() in testSetup to verify the values are being returned.","B. Verify the user has permissions passing a user into System,.runds().","C. Call the Apex class method from a testsetup Instead of the testsetup methed.","D. Add @testvisible to the method in the class the developer is testing."],"answer":"D","title":"Question 69","explanation":"When an Apex class does not achieve the expected code coverage, it suggests that the test methods are not executing parts of the class. The @testvisible annotation can be used to increase code coverage by allowing test methods to access private or protected members of another class. This enables the test method to call methods that may not be directly accessible, but it is not a direct means to generate code coverage. The code coverage is actually achieved when the test methods execute the code within these methods. Therefore, to properly generate code coverage, the developer must ensure that the test methods call the relevant portions of the code that need to be covered. The use of @testvisible can facilitate this process by making otherwise inaccessible code available for testing.\n References:\n Apex Developer Guide - Testing Best Practices\n Apex Developer Guide - @testVisible Annotation"},{"content":"A developer is tasked with creating a Lightning web component that is responsive on various devices, Which two components should help accomplish this goal?\nChoose 2 answers","options":["A. lightning-navigation","B. Lightning-input-location","C. Lightning-layout","D. lightning-layout--item"],"answer":"C,D","title":"Question 70","explanation":"Lightning-layout and lightning-layout-item are components used in Lightning Web Components to create responsive grid layouts that adapt to the screen size of various devices.\n References:\n Lightning Layout: Component Reference\n Lightning Layout Item: Component Reference"},{"content":"A developer created a Lightning web component that uses a lightning-record-edit-form to collect information about Leads. Users complain that they only see one error message at a time about their input when trying to save a Lead record.\nWhat is the recommended approach to perform validations on more than one field, and display multiple error messages simultaneously with minimal JavaScript intervention?","options":["A. Try/catch/finally block","B. External JavaScript library","C. Validation rules","D. Apex trigger"],"answer":"C","title":"Question 71","explanation":"Salesforce validation rules are declarative and can be used to validate more than one field on an object and display multiple error messages. This approach requires minimal JavaScript code and uses Salesforce's built-in validation framework. References:\n Validation Rules"},{"content":"A developer created a JavaScript library that simplifies the development of repetitive tasks and features and uploaded the library as a static resource called rsutils in Salesforce. Another developer is coding a new Lightning web component (LWC) and wants to leverage the library, Which statement properly loads the static resource within the LWC?","options":["A. import jsUtilities from '@salesforce/rescurceUr1/jaUtiles';","B. <lightning-require scripts=\"{|$Resource,jaUtils}\"/>","C. const jsUtilivy = SA.get{'SResource.isUtils');","D. impore {jsUtilities} from '@salasforce/resourceUrl/jsUtils';"],"answer":"D","title":"Question 72","explanation":"To load a static resource within a Lightning web component, you should use an import statement with the\n @salesforce/resourceUrl module. This statement correctly refers to the static resource by its name.References: Lightning Web Components Developer Guide - Use Static Resources"},{"content":"Just prior to a new deployment the Salesforce administrator, who configured a new order fulfillment process feature in a developer sandbox, suddenly left the company.\nAg part of the UAT cycle, the users had fully tested all of the changes in the sandbox and signed off on them; making the Order fulfillment feature ready for its go-live in the production environment.\nUnfortunately, although a Change Set was started, it was not completed by the former administrator.\nA developer is brought in to finish the deployment.\nWhat should the developer do to identify the configuration changes that need to be moved into production?","options":["A. In Salesforce setup, look at the last modified date for every object to determine which should be added to the Change Set.","B. Use the Metadata API and a supported development IDE to push all of the configuration from the sandbox into production to ensure no changes are lost.","C. Leverage the Setup Audit Trail to review the changes made by the departed Administrator and identify which changes should be added to the Change Set.","D. Set up Continuous Integration and a Git repository to automatically merge all changes from the sandbox metadata with the production metadata."],"answer":"C","title":"Question 73","explanation":"To identify the configuration changes made by the former administrator, the developer should leverage the Setup Audit Trail. This allows tracking changes made in the Setup area of Salesforce, showing the date of the change, who made it, and what the change was.References: Salesforce Help - Monitor Setup Changes"},{"content":"A developer needs to implement a system audit feature that allows users, assigned to a custom profile named\n\"Auditors\", to perform searches against the historical records in the Account object. The developer must ensure the search is able to return history records that are between 6 and 12 months old.\nGiven the code below, which select statement should be inserted below as a valid way to retrieve the Account History records ranging from 6 to 12 months old?","options":["A. ","B. ","C. ","D. "],"answer":"B","title":"Question 74","explanation":"Given the code snippet, the correct query to retrieve Account History records between 6 and 12 months old would be the one that includes a WHERE clause filtering records where the CreatedDate is greater than or equal to initialDate and less than or equal to endDate. Option B's statement does this correctly by using the >\n = and <= operators to define the range between initialDate (which is set to today's date minus 12 months) and endDate (set to today's date minus 6 months). Options A, C, and D either use incorrect comparison operators or compare against the wrong variables, resulting in an incorrect data set being returned.\n References\n SOQL Date Formats and Date Literals: SOQL and SOSL Reference Guide"},{"content":"For compliance purposes, a company is required to track long-term product usage in their org. The information that they need to log will be collected from more than one object and, over time, they predict they will have hundreds of millions of records.\nWhat should a developer use to implement this?","options":["A. Setup audit trail","B. Field audit trail","C. Big objects","D. Field history tracking"],"answer":"C","title":"Question 75","explanation":"Big objects provide a solution for storing and managing large amounts of data within Salesforce. They are ideal for compliance purposes when tracking long-term usage data that will accumulate over time into very large record counts.References: Salesforce Developer Guide - Big Objects"},{"content":"A company has reference data stored in multiple custom metadata records that represent default information and delete behavior for certain geographic regions.\nWhen a contact is inserted, the default information should be set on the contact from the custom metadata records based on the contact's address information.\nAdditionally, if a user attempts to delete a contact that belongs to a flagged region, the user must get an error message.\nDepending on company personnel resources, what are two ways to automate this?\nChoose 2 answers","options":["A. Remote action","B. Flow Builder","C. Apex trigger","D. Apex invocable method"],"answer":"B,C","title":"Question 76","explanation":"To automate the process based on the contact's address information and prevent deletion from flagged regions:\n Flow Builder: Can be used to set default information on records when they are created.\n Apex Trigger: Allows for complex logic to be executed before or after data manipulation operations, including insert and delete. It can be used to enforce rules such as preventing deletion.\n References:\n Flow Builder: Salesforce Help Article\n Apex Triggers: Apex Developer Guide"},{"content":"Refer to the test method below:\nThe test method calls an @future method that increments the\nNumber_of_Times_Viewed__c value. The assertion is failing because the\nNumber of Times Viewed_c equals 0.\nWhat is the optimal way to fix this?","options":["A. Change the assertion to system.asserciquals (0, acctAfter Number _Cf_Timea_Viewed__c).","B. Add Test.atartTeat() before and Teat.stopTest() after inser= acct.","C. Add rest.staztTest() before and Test.stopTess() after AuditUcil.incrementViewed.","D. Change the initialization to acct. Number_Of_Times_Viewed_c = 1."],"answer":"C","title":"Question 77","explanation":"When a test method calls an @future method that performs DML operations, the changes made by the\n @future method won't be visible until after the Test.stopTest() is called. This method ensures that all asynchronous processes are completed before the test execution continues. Therefore, Test.startTest() should be before the call to the @future method and Test.stopTest() immediately after.References: Apex Developer Guide - Testing Asynchronous Apex"},{"content":"An Apex trigger creates an order co record every time an Opportunity is won by a Sales Rep. Recently the trigger is creating two orders.\nWhat is the optimal technique for 2 developer to troubleshoot this?","options":["A. Disable all flows, and then re-enable them one at at time to see which one causes the error.","B. Run the Apex Test Classes for the Apex trigger to ensure the code still has sufficient code coverage.","C. Set up debug logging for every Sales Rep, then monitor the logs for errors and exceptions,","D. Add system.debug() statements to the code and use the Developer Console logs to trace the code."],"answer":"D","title":"Question 78","explanation":"To troubleshoot the issue of a trigger creating two order records, adding System.debug() statements in the trigger and analyzing the log output in the Developer Console is an effective technique. This will help identify if the trigger is being called more than once or if there is another automation (such as a flow or workflow) causing the additional record creation.References: Salesforce Developer Guide - Debugging"},{"content":"Given a list of Opportunity records named opportunityList, which code snippet is best for querying all Contacts of the Opportunity's Account?","options":["A. ","B. ","C. ","D. "],"answer":"C","title":"Question 79","explanation":""},{"content":"The use of the transient keyword in Visualforce page controllers helps with which common performance issue?","options":["A. Reduces load times","B. Improves page transfers","C. Reduces view state","D. Improves query performance"],"answer":"C","title":"Question 80","explanation":"The transient keyword in Visualforce page controllers marks variables that should not be part of the view state, which can significantly reduce the size of the view state. This can help avoid view state limit errors and improve page performance because a smaller view state requires less time to send to the client.References:\n Visualforce Developer Guide - Reducing View State Size"},{"content":"Refer to the following code snippet:\nA developer created a JavaScript function as part of a Lightning web component (LWC) that surfaces information about Leads by wire calling geyFetchLeadList whencertain criteria are met.\nWhich three changes should the developer implement in the Apex class above to ensure the LWC can display data efficiently while preserving security?\nChoose 3 answers","options":["A. Annotate the Apex method with @AuraEnabled.","B. Implement the with sharing keyword in the class declaration.","C. Implement the with keyword in the class declaration.","D. Use the WZ E D clause within the SOQL query.","E. Annotate the Apex method with @AuraEnabled(Cacheable=True)."],"answer":"A,B,E","title":"Question 81","explanation":"The Apex class needs to have the method annotated with @AuraEnabled to expose it to the LWC. The 'with sharing' keyword ensures that the data access is enforced according to the user's permissions.\n @AuraEnabled(cacheable=true) allows client-side caching for improved performance.\n References:\n @AuraEnabled Annotation: Apex Developer Guide\n Enforcing Sharing Rules: Apex Developer Guide"},{"content":"Universal Containers develops a Visualforce page that requires the inclusion of external JavaScript and C55 files. They want to ensure efficient loading and caching of the page.\nWhich feature should be utilized to achieve this goal?","options":["A. ActionFunction","B. PageBlockTable","C. Static resources","D. RemoteAction"],"answer":"C","title":"Question 82","explanation":"Static resources are ideal for efficient loading and caching of external files in Visualforce. They allow bundling and minimizing HTTP requests.References: Using Static Resources"},{"content":"Given the following code:\nAssuming there were 10 Contacts and five Accounts created today, what is the expected result?","options":["A. System.QueryException: Too many DML Statement errors on Contact","B. System.QueryException: List has more than one row for Assignment on Account","C. Systemn.LimitException: Too many SOQL Queries on Account","D. System.LimitException: Too many SOQL Queries on Contact"],"answer":"B","title":"Question 83","explanation":"The loop contains a SOQL query inside, causing it to run multiple times. This will throw a QueryException because the Account query returns more than one row.References: Apex Developer Guide - SOQL Queries"},{"content":"Salesforce users consistently receive a \"Maximum trigger depth exceeded\" error when saving an Account.\nHow can a developer fix this error?","options":["A. Split the trigger logic into two separate triggers.","B. Convert the trigger to use the 3suzure annotation, and chain any subsequent trigger invocations to the Account object.","C. Modify the trigger to use the L=MultiThread=true annotation,","D. Use a helper class to set a Boolean to TRUE the first time a trigger 1s fired, and then modify the trigger ta only fire when the Boolean is FALSE."],"answer":"D","title":"Question 84","explanation":"A common solution to the \"Maximum trigger depth exceeded\" error is to use a static variable in a helper class.\n The variable acts as a switch to ensure the trigger logic only executes once per transaction, preventing recursive trigger calls.References: Salesforce Developer Blog - Avoiding Recursive Trigger Calls"},{"content":"Universal Containers ne=ds to integrate with several external systems. The process Is Initiated when a record Is created in Salesforce, The remote systems do not require Salesforce to wait for a response before continuing.\nWhat is the recommended best solution to accomplish this?","options":["A. Qutbound message","B. PushTopic event","C. Platform event","D. Trigger with HTTP callout"],"answer":"C","title":"Question 85","explanation":"Platform events provide a robust and scalable way to communicate changes and events from Salesforce to external systems, especially when there is no requirement for Salesforce to wait for a response. They are designed to support event-driven architectures and can handle high volumes of events that can be published and consumed by external systems. Outbound messages, on the other hand, are limited by the need for an acknowledgment response from the target system, which can introduce latency."},{"content":"Consider the Apex class below that defines a RemoteAction used on 2 Visualforce search page.\nWhich code snippet will assert that the remote action returned the correct Account?","options":["A. ","B. ","C. ","D. "],"answer":"C","title":"Question 86","explanation":"The correct code snippet to assert that the remote action returned the correct Account is option C. This is because the getAccount method is a global static method within the MyRemoter class and can be directly called without needing to instantiate an object of the class.References: Apex Developer Guide - Exposing Apex Methods to JavaScript"},{"content":"Refer to the Lightning component below:\nThe Lightning Component allows users to click a button to save their changes and then redirects them to a different page.\nCurrently when the user hits the Save button, the records are getting saved, but they are not redirected.\nWhich three techniques can a developer use to debug the JavaScript?\nChoose 3 answers","options":["A. Use console.log () messages in the JavaScript.","B. Use the browser's dev tools to debug the JavaScript.","C. Enable Debug Mode for Lightning components for the user.","D. Use Developer Console to view checkpoints.","E. Use Developer Console to view the debug log."],"answer":"A,B,C","title":"Question 87","explanation":"When debugging JavaScript in a Lightning Component, developers can utilize the following techniques:\n A: Use console.log() messages in the JavaScript: This is a standard debugging technique to log information to the browser console, which can help trace the execution flow or output variable values.\n B: Use the browser's dev tools to debug the JavaScript: Modern browsers come equipped with developer tools that can be used to set breakpoints, step through code, and inspect variables at runtime.\n C: Enable Debug Mode for Lightning components for the user: Enabling Debug Mode for users provides more detailed error messages and unminified versions of client-side libraries, making it easier to debug issues.\n Using the Developer Console to view checkpoints (Option D) and debug logs (Option E) is more relevant for Apex debugging rather than JavaScript.\n References:\n Salesforce Documentation on Debugging Lightning Components: Debugging"},{"content":"A company wants to incorporate a third-party weh service to set the Address fields when an Account is inserted, if they have not already been set.\nWhat is the optimal way to achieve this?","options":["A. Create a Workflow Rule, execute a Queueable job from it, and make a callout from the Queueable job.","B. Create an Apex trigger, execute a Queueable job from it, and make a callout from the Queueable job.","C. Create a Process, execute a Quaueable job from it, and make a callout from the Queueable job.","D. Create a Before Save Flow, execute a Queueable job from it, and make a callout from the Queusable job."],"answer":"B","title":"Question 88","explanation":"To make a callout to set the Address fields when an Account is inserted without violating the Salesforce limit against callouts from triggers, a developer can use a trigger to execute a Queueable job. The Queueable job can then safely make the callout.References: Apex Developer Guide - Queueable Apex"},{"content":"How can a developer efficiently incorporate multiple JavaScript libraries in an Aura component?","options":["A. Use JavaScript remoting and script tags.","B. Use CDNs with script attributes.","C. Implement the libraries in separate helper files.","D. Join multiple assets from a static resource."],"answer":"D","title":"Question 89","explanation":"For incorporating multiple JavaScript libraries in Aura components, the best practice is to join multiple assets into a single static resource. This approach is efficient and avoids issues with asynchronous loading and potential conflicts between libraries. References: Aura Components Developer Guide - Using External JavaScript Libraries"},{"content":"A developer is asked to modify a Lightning web component so that it displays in one column on phones and in two columns on tablets, desktops, and larger devices.\nGiven to the code below:\nWhich should the developer add to the code to meet the requirements?","options":["A. ","B. ","C. ","D. "],"answer":"B","title":"Question 90","explanation":"The requirement is for the Lightning web component to display in one column on phones and in two columns on larger devices. To achieve this, we should specify the size attributes for different devices using the design tokens provided by the Lightning Design System.\n Option B is correct because size=\"6\" will set each lightning-layout-item to take up half the available space (since the grid system is based on a 12-column structure), creating two columns on tablets, desktops, and larger devices. small-device-size=\"12\" will ensure that on small devices like phones, each item will take up the full width, resulting in a single column.\n Options A, C, and D do not meet the requirement correctly, as they either do not set the size correctly for small devices or do not specify the sizes for both small and larger devices appropriately.\n References:\n Lightning Design System Grid Documentation: Lightning Grid"}]